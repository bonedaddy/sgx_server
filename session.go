package sgx_server

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/aead/cmac"
)

// MSG4_SECRET is what is sent in the last message of SGX
// attestation, encrypted under a key shared between the server and
// the client during attestation. You can either change this to
// a different value, or dynamically generate secrets to send to
// different enclaves for various reasons.
const MSG4_SECRET = "REPLACE_ME_WITH_REAL_SECRET"

// Magic constants used to check the SGX attestation quote.
var (
	KDF_ID           = []byte{1, 0}
	UNLINKABLE_QUOTE = []byte{0, 0}
	LINKABLE_QUOTE   = []byte{1, 0}
)

// Magic constants used to check the SGX attestation quote.
const (
	UNLINKABLE_QUOTE_INT = 0
	LINKABLE_QUOTE_INT   = 1
	KDF_ID_INT           = 1
	EC_COORD_SIZE        = 32
	EPID_GID_SIZE        = 4
)

// Magic constants for deriving cryptographic keys for SGX sessions.
var (
	SMK_LABEL = []byte{'S', 'M', 'K'}
	VK_LABEL  = []byte{'V', 'K'}
	SK_LABEL  = []byte{'S', 'K'}
	MK_LABEL  = []byte{'M', 'K'}
)

// Session represents a logical connection between an SGX client and
// this server.
type Session interface {
	// Id returns the id associated with this session.
	// Usually hex encoded 16 byte random value, if created using
	// the default SessionManager provided in this module.
	Id() string

	// ProcessMsg1 processes the SGX message 1 (which actually
	// contains SGX message 0 as well), and updates the internal
	// states of the session.
	ProcessMsg1(msg1 *Msg1) error

	// CreateMsg2 returns the message 2 after processing
	// message 1.
	CreateMsg2() (*Msg2, error)

	// ProcessMsg3 receives the SGX message 3 (which contains
	// things like the enclave quote), and verifies the validity
	// of the message with the Intel Attestation Service.
	ProcessMsg3(msg3 *Msg3) error

	// CreateMsg4 returns the last message in SGX attestation.
	CreateMsg4() (*Msg4, error)

	// Authenticated returns if the session has been
	// authenticated.
	Authenticated() bool

	// Seal uses authenticated encryption to encrypt msg for the
	// SGX client. It uses AES GCM to encrypt the message with
	// a random nonce, and it prepends the nonce the resulting
	// ciphertext. The key used is SK derived during the
	// attestation process. This function MUST be called AFTER
	// ProcessMsg3 returns no error.
	Seal(msg []byte) ([]byte, error)

	// Open decrypts and verifies the integrity of a ciphertext
	// generated using Seal. In practice, the ciphertext will
	// be generated by the client which implements the same
	// Seal and Open protocol.
	Open(ciphertext []byte) ([]byte, error)

	// MAC generates a message authentication code using MK
	// derived during the attestation process. It uses CMAC
	// based on AES to genearate the MAC, which is the standard
	// for SGX.
	MAC(msg []byte) []byte

	// Expires returns an error if the sesion is expired already.
	Expired() error
}

type session struct {
	id      string
	timeout int
	ias     IAS

	mrenclaves  [][32]byte
	spid        []byte
	longTermKey *ecdsa.PrivateKey
	exgid       uint32
	gid         []byte
	ga          *PublicKey
	gb          *PublicKey

	// Various session keys.
	ephKey *ecdsa.PrivateKey
	kdk    []byte
	smk    []byte
	vk     []byte
	sk     []byte
	mk     []byte

	pseTrusted    bool
	pib           []byte
	authenticated bool

	aes cipher.AEAD

	// Count the number of encryption operations done in this
	// session. If sealCount goes over 2^{32}, it will throw
	// an error.
	sealCount int

	lastUsed time.Time
}

// NewSession creates a new session with id. If a session is not used
// for timeout minutes, then the session is considered invalid.
// NewSession also receives the interface to IAS, a list of
// MREnclaves, the SPID for this server, and the private key whose
// public key is baked into the enclave.
func NewSession(id string, timeout int, ias IAS, mrenclaves [][32]byte, spid []byte, longTermKey *ecdsa.PrivateKey) Session {
	s := &session{
		ias:        ias,
		timeout:    timeout,
		mrenclaves: mrenclaves,

		id:          id,
		spid:        spid,
		longTermKey: longTermKey,

		pseTrusted:    false,
		authenticated: false,

		ephKey: generateKey(),

		sealCount: 0,

		lastUsed: time.Now(),
	}
	return s
}

func (sn *session) Id() string {
	return sn.id
}

func (sn *session) ProcessMsg1(msg1 *Msg1) error {
	if err := sn.Expired(); err != nil {
		return err
	} else if !checkMsg1Format(msg1) {
		return errors.New("Malformed message 1")
	}

	sn.exgid = msg1.Msg0.Exgid
	sn.ga = msg1.Ga
	sn.gid = msg1.Gid

	sn.lastUsed = time.Now()
	return nil
}

func (sn *session) CreateMsg2() (*Msg2, error) {
	if err := sn.Expired(); err != nil {
		return nil, err
	}

	gbx, gby, err := marshalPublicKey(&sn.ephKey.PublicKey)
	if err != nil {
		return nil, err
	}
	sn.gb = &PublicKey{
		X: gbx,
		Y: gby,
	}

	keyMsg := append(gbx, gby...)
	keyMsg = append(keyMsg, sn.ga.X...)
	keyMsg = append(keyMsg, sn.ga.Y...)

	sum := sha256.Sum256(keyMsg)
	r, s, err := ecdsa.Sign(rand.Reader, sn.longTermKey, sum[:])
	if err != nil {
		return nil, err
	}

	sig := &Signature{
		R: serializeBigInt(r),
		S: serializeBigInt(s),
	}

	enclavePub, err := unmarshalPublicKey(sn.ga.X, sn.ga.Y)
	if err != nil {
		return nil, err
	}

	sn.kdk, sn.smk = deriveLabelKey(sn.ephKey, enclavePub, SMK_LABEL)

	a := &A{
		Gb:        sn.gb,
		Spid:      sn.spid,
		QuoteType: UNLINKABLE_QUOTE,
		KdfId:     KDF_ID,
		Signature: sig,
	}

	sigRl, err := sn.ias.GetRevocationList(sn.gid)
	if err != nil {
		return nil, err
	}

	msg2 := &Msg2{
		A:         a,
		CmacA:     sn.cmacA(a),
		SigRlSize: uint32(len(sigRl)),
		SigRl:     sigRl,
	}

	sn.lastUsed = time.Now()
	return msg2, nil
}

func (sn *session) ProcessMsg3(msg3 *Msg3) error {
	if err := sn.Expired(); err != nil {
		return err
	}

	// Used in hash report so derived ahead of all the other keys.
	sn.vk = deriveLabelKeyFromBase(sn.kdk, VK_LABEL)

	if !bytes.Equal(msg3.M.Ga.X, sn.ga.X) {
		fmt.Println("X", msg3.M.Ga.X, sn.ga.X)
		return errors.New("Msg3 GA mismatch.")
	} else if !bytes.Equal(msg3.M.Ga.Y, sn.ga.Y) {
		fmt.Println("Y", msg3.M.Ga.Y, sn.ga.Y)
		return errors.New("Msg3 GA mismatch.")
	} else if !bytes.Equal(sn.cmacM(msg3.M), msg3.CmacM) {
		return errors.New("Msg3 MAC on M mismatch.")
	} else if !bytes.Equal(sn.hashReport(), msg3.M.Quote[368:368+32]) {
		return errors.New("Hash mismatch on report.")
	}

	var mr [32]byte
	copy(mr[:], msg3.M.Quote[112:112+32])

	found := false
	for _, valid := range sn.mrenclaves {
		if mr == valid {
			found = true
			break
		}
	}
	if !found {
		return errors.New("Invalid MREnclave.")
	}

	pseTrusted, pib, err := sn.ias.VerifyQuoteAndPSE(msg3.M.Quote, msg3.M.PsSecurityProp)
	sn.pseTrusted = pseTrusted
	sn.pib = pib
	if err != nil {
		return err
	}

	sn.authenticated = true

	sn.sk = deriveLabelKeyFromBase(sn.kdk, SK_LABEL)
	sn.mk = deriveLabelKeyFromBase(sn.kdk, MK_LABEL)

	block, err := aes.NewCipher(sn.sk)
	if err != nil {
		return err
	}
	sn.aes, err = cipher.NewGCM(block)
	if err != nil {
		return err
	}

	sn.lastUsed = time.Now()
	return nil
}

func (sn *session) CreateMsg4() (*Msg4, error) {
	if err := sn.Expired(); err != nil {
		return nil, err
	}

	var ciphertext []byte
	if sn.authenticated {
		var err error
		secret := []byte(MSG4_SECRET)
		ciphertext, err = sn.Seal(secret)
		if err != nil {
			return nil, err
		}
	}

	// authenticated, pseTrusted, pib are all set in ProcessMsg3.
	msg4 := &Msg4{
		EnclaveTrusted: sn.authenticated,
		PseTrusted:     sn.pseTrusted,
		Pib:            sn.pib,
		Secret:         ciphertext,
	}
	msg4.Cmac = sn.cmacMsg4(msg4)
	return msg4, nil
}

func (sn *session) Authenticated() bool {
	return sn.authenticated
}

func (sn *session) Seal(msg []byte) ([]byte, error) {
	if err := sn.Expired(); err != nil {
		return nil, err
	} else if sn.sealCount > (1 << 32) {
		return nil, errors.New("Sealed too many messages.")
	}

	nonce := make([]byte, 12)
	_, err := rand.Read(nonce)
	if err != nil {
		return nil, err
	}

	ciphertext := sn.aes.Seal(nil, nonce, msg, nil)
	sn.sealCount += 1
	sn.lastUsed = time.Now()
	return append(nonce, ciphertext...), nil
}

func (sn *session) Open(ciphertext []byte) ([]byte, error) {
	if err := sn.Expired(); err != nil {
		return nil, err
	}

	sn.lastUsed = time.Now()
	return sn.aes.Open(nil, ciphertext[:12], ciphertext[12:], nil)
}

func (sn *session) MAC(msg []byte) []byte {
	return cmacWithKey(msg, sn.mk)
}

func (sn *session) Expired() error {
	if sn.timeout == -1 { // timeout == -1 means it never expires
		return nil
	}

	now := time.Now()
	if now.After(sn.lastUsed.Add(time.Duration(sn.timeout) * time.Minute)) {
		return errors.New(fmt.Sprintf("Session [%s] timed out.", sn.id))
	}
	return nil
}

func checkMsg1Format(msg1 *Msg1) bool {
	return len(msg1.Ga.X) == EC_COORD_SIZE &&
		len(msg1.Ga.Y) == EC_COORD_SIZE &&
		len(msg1.Gid) == EPID_GID_SIZE
}

func cmacWithKey(msg, key []byte) []byte {
	block, err := aes.NewCipher(key[:])
	if err != nil {
		log.Fatal("Could not create AES for CMAC: ", err)
	}

	result, err := cmac.Sum(msg, block, aes.BlockSize)
	if err != nil {
		log.Fatal("Could not CMAC the message.")
	}
	return result
}

func (sn *session) cmacA(a *A) []byte {
	concat := append(a.Gb.X, a.Gb.Y...)
	concat = append(concat, a.Spid...)
	concat = append(concat, a.QuoteType...)
	concat = append(concat, a.KdfId...)
	concat = append(concat, a.Signature.R...)
	concat = append(concat, a.Signature.S...)
	return cmacWithKey(concat, sn.smk)
}

func (sn *session) cmacM(m *M) []byte {
	concat := append(m.Ga.X, m.Ga.Y...)
	concat = append(concat, m.PsSecurityProp...)
	concat = append(concat, m.Quote...)
	return cmacWithKey(concat, sn.smk)
}

func (sn *session) cmacMsg4(msg4 *Msg4) []byte {
	b1 := []byte{0}
	if msg4.EnclaveTrusted {
		b1[0] = 1
	}
	b2 := []byte{0}
	if msg4.PseTrusted {
		b2[0] = 1
	}
	concat := append(b1, b2...)
	concat = append(concat, msg4.Pib...)
	concat = append(concat, msg4.Secret...)
	return cmacWithKey(concat, sn.smk)
}

func (sn *session) hashReport() []byte {
	concat := append(sn.ga.X, sn.ga.Y...)
	concat = append(concat, sn.gb.X...)
	concat = append(concat, sn.gb.Y...)
	concat = append(concat, sn.vk...)
	hash := sha256.Sum256(concat)
	return hash[:]
}
